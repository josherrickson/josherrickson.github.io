[
["index.html", "Introduction to Stata (SOC 510) Chapter 1 Preface 1.1 How to use this document 1.2 Contact information 1.3 Acknowledgments", " Introduction to Stata (SOC 510) Josh Errickson 2017-09-12 Chapter 1 Preface 1.1 How to use this document These notes are published in bookdown format which enables easy creation of longform documents (using a mixture of markdown, R, and for these notes specifically, Stata’s dyndoc). The table of contents is found on the left hand side, with subsections expanding below the current section. At the top of the page are three icons, from left to right they 1) Hide/show the table of contents, 2) Search this document, and 3) Change the font the book is displayed in. All images should link to full-size versions to see detail if needed. 1.1.1 Stata 14 vs Stata 15 Given that Stata 15 has been released relatively recently to this workshop (July 2017), while the workshop is designed with and taught towards Stata 15, we will flag areas where Stata 14 performs differently. Look for the following image to designate such areas: 1.2 Contact information 1.2.1 CSCAR Office Hours: Monday-Friday 9am to 5pm (Closed Tuesday 12-1pm) Phone: 734.764.7828 Statistical Assistance: stats-consulting@umich.edu Data Science Assistance: ds-consulting@umich.edu High Performance Computing: hpc-consulting@umich.edu http://cscar.research.umich.edu/ 1.2.2 Author Josh Errickson 3550 Rackham Building 915 E. Washington Street Ann Arbor, MI 48109-1070 Email: jerrick@umich.edu 1.3 Acknowledgments These notes have evolved over the years thanks to many CSCAR statisticians, including Giselle Kolenic, Brady West, Heidi Reichert, and Lingling Zhang. This material was created for use in workshops and short courses presented by faculty and staff from the Consulting for Statistics, Computing &amp; Analytics Research (CSCAR) at the University of Michigan. No part of this material may be used for other purposes, copied, changed, or sold. "],
["basics.html", "Chapter 2 Basics 2.1 The Stata Environment 2.2 One Data 2.3 Give Stata a command 2.4 Do-files 2.5 Basic command syntax 2.6 Stata Help 2.7 set more off 2.8 Working directory", " Chapter 2 Basics 2.1 The Stata Environment When a user first opens Stata, there are five main windows that will appear: The Results Window All commands which are run are echoed out here, as well as any output they produce. Not all commands produce output though most do (e.g. obtaining summaries of the data or running a statistical procedure). Items that appear in the results window in blue are clickable. The Command Window This window is where users can interactively type Stata commands and submit them to Stata for processing. Everything that one can do in Stata is based on a set of Stata commands. Stata commands are case sensitive. All Stata commands and options are in lower case. When variables are used in any command, the variable names are also case sensitive. The Variables Window This window displays all of the variables in the data set that is currently open in Stata, and users can click on variable names in this window to carry the variables over into Stata commands in the Command window. Note that Stata allows only one data-set to be open in a session. The Review Window Stata will keep a running record of all Stata commands that have been submitted in the current session in this window. Users can simply click on previous commands in this window to recall them in the Command window. The Properties Window This window allows variable properties and data-set properties to be managed. Variable names, labels, value labels, notes, display formats, and storage types can be viewed and modified here. Each of these five windows will be nested within a larger overall window for the Stata session, which contains menus and tool bars available for users. There are additional windows that users can access from the Window menu, which include the Graph window (which will open when graphs have been created), the Viewer window (which is primarily used for help features and Stata news), the Data Editor window (for use when viewing data sets), and the Do-file Editor window (for use when writing .do files). In the lower left-hand corner of the main Stata window, there will be a directory displayed. This is known as the working directory, and is where Stata will look to find data files and other associated Stata files unless the user specifies another directory. We will cover examples of changing the working directory. 2.2 One Data One functionality where Stata differs than most other statistical or data analysis software is that Stata can only have a single data set open at a time. (You can open a second instance of Stata to open a second data set, but the two instances cannot communicate.) Any command you run knows to operate on the data set you have open. For example, there is a command summarize which provides summary information about variables. The command is simply summarize, there is no need to direct it towards a specific data set. If you have multiple data sets you need to work with, you can either Switch between the two data sets as needed. This can be burdensome, though tools such as preserve help greatly. Merge the data sets, the better option. We won’t be covering this in this workshop, but the command to look into the help for is merge. 2.3 Give Stata a command Let’s try running a Stata command. In the command window, type (or copy) the following: version The following should appear in the Results window: . version version 15.0 The first line proceeded by the . indicates the command that was written, version, and the rest is the output. Here, I am running Stata version 15.0 (your version may vary). In this document, if you see a single command without a period, it indicates something that can be run. If you instead see a Results output where the first line is the command prefaced by the ., that was run in Stata and only the Results are included since they include the command. The command can still be run, but should be run without the ..1 2.3.1 Saving Results Any output that appears in the Results window (including the echoed commands and any errors) can by copied to be pasted into another location, such as Word. In addition, if you highlight text and right-click, you also have the options: “Copy table”: Useful for exporting to Excel. This can be tempermental; if the selected table is less “regular”, this may not produce the best results. It is most useful for text which comes naturally as a table rather than results which are forced into a table for display purposes. “Copy table as HTML”: You can paste this into a plaintext editor (Notepad.exe or TextEdit, not Word) and save it as a *.html to produce a webpage. If you paste this into Excel you get a slightly different table than the layout for “Copy table” which may be more useful. “Copy as picture”: Does exactly what it says - equivalent to taking a screenshot. Very handy! There are a few commands that can be useful for saving results which we will not cover in this workshop, if you are interested, you can look into the help for them. log: Saves everything that goes into Results into a file. putexcel: Adds to a spreadsheet specific strings or output. 2.4 Do-files We saw that commands can be typed interactively, one command at a time, and the results immediately observed. From this, the output can be copied/exported/printed, or the results can be saved. However, a better paradigm would save all the commands run separately so that the analysis is reproducible. For this purpose, Stata has Do-files (named because they are saved with the .do extension, such as analysis.do) which are scripts containing only commands and comments. We can then run any subset of the commands (including the entire file), re-running parts or all of the analysis. Additionally you can easily save and/or share this command, allowing yourself or a colleague to re-run the analysis. There are several ways to start a new Do-file. File -&gt; New -&gt; Do-file You can enter the command doedit If you select some commands in the Review window, you can right click and choose “Send select to Do-file Editor”. For the last option there, note that performing that twice will create two separate Do-files instead of appending the commands. Instead, you can copy and paste from the Review window to add to an existing Do-file. Let’s manually add some commands to a Do-file to see how to execute the commands. In a Do-file editor, enter the following sysuse auto summarize price Once the lines are in the editor, highlight the commands (you do not need to highlight the entire line, you merely need to ensure your selection includes part of every line you want run) and press the “Execute/Do” (on Windows) or “Do” (on Mac) button. You should see the following appear in your Results window. . sysuse auto (1978 Automobile Data) . summarize price Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 74 6165.257 2949.496 3291 15906 We will cover in later sections what these commands do (sysuse and summarize). 2.4.1 Comments Comments are information in a Do-file which Stata will ignore. They can be used to stop a command from running without deleting it, or more usefully, to add information about the code which may be useful for others (or yourself in the future) to understand how some code works or to justify you made choices you did. In general, comments can also help readability. There are three different ways to enter comments (and one additional special way). First, to comment out an entire line, precede it by *: . * This is a comment Second, you can add a comment to the end of a line with `//`` . version // Returns the Stata version number version 15.0 . // You can also use it to comment out an entire line. Note that there must be a space before the // if it comes after a command: . version// Returns the Stata version number invalid syntax r(198); Thirdly, you can comment out a section by wrapping it in /* and */ . /* Here's a several &gt; line comment. &gt; It just keeps going. */ . summarize /* comment in the middle of a command! */ price Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 74 6165.257 2949.496 3291 15906 Note that when a command wraps to more than one line in the Results window (either due to a manual line break like this or a command that’s too wide for the Results window), the prefix changes from . to &gt; to indicate that its all one command. Finally, there’s the special comment, ///. Stata commands must be on a single line. However, complicated commands may get very long, such that its hard to read them on a single line. Using /// instead of // allows wrapping onto the next line. . summarize /// &gt; price Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 74 6165.257 2949.496 3291 15906 As with //, there needs to be a space before the ///. Note, only the * works on interactive commands entered in the Command window. All four versions work in Do-files. 2.4.2 Version control When writing a Do-file, you generally are creating it while using a single version of Stata. If a new version of Stata were released, its possible that your code may operate differently with the new version. If you add version 14.2 to the beginning of your Do-file, Stata will execute the commands as if it were still running version 14.2, even if you’ve updated to Stata 15. This works all the way back to Stata 2. (Obviously, this will not work if you try to run as Stata 15 when you only have Stata 14 installed.) Note that this version is the same command as the version we’ve been discussing before. It operates in this special fashion only when included at the top of a Do-file. Best practices is to always include a version ##.# line at the top of each Do-file, but if its code that will continue to see use, you should test it with the newer releases and update the code as necessary! 2.5 Basic command syntax Most commands which operate on variables (as opposed to system commands such as version that we’ve been discussing) follow the same general format. Recognizing this format will make it easier to understand new commands that you are introduced. The basic syntax is command &lt;variable(s)&gt;, &lt;options&gt; The command can take on more than one word; e.g. to create a scatter plot, the command is graph twoway scatter. Depending on the command, the list of variables can contain 0 variables, 1 variable, or many variables separated by spaces. Whether the order of variables matters depends on the specific command. The options are not required, but if they are given, they too are separated by spaces. There are some options that are consistent across a number of commands, and some options are specific to commands. There’s an additional piece; if you want to run a command on a subset of the data, we add to the syntax: command &lt;variable(s)&gt; if &lt;condition&gt;, &lt;options&gt; We will cover this in more detail later, including how to specify the condition. As an example, if we were to fit a linear regression model2, the command might be regress y x1 x2 x3 x4 if z &gt; 5, vce(robust) beta Without getting too into the details of how the command works, we can see examine the command. The command is regress. In the list of variables, the first position (the y) is in a privileged position as the dependent variable, and all remaining variables are independent. (In other words, the y variable is of one type, the remainder (in any order) are another type.) We are fitting the model on the subset where z &gt; 5. There are two options, vce(robust) which changes how the model is estimated and beta which changes how the output is displayed. 2.5.1 Referring to variables In the example of the regress command above, 4 variables we referred to were x1 through x4. If you have only a few variables to refer to, typing each in (or double-clicking on their entry in the Variables window) is sufficient. However, if the number of variables grows, this becomes tedious. Thankfully there are two alternatives. First, we can use the wild card *3 For example, we could refer to those four “x” variables as x*. However, be careful, as this would also match x5, x6, xage, xcats, etc. It can also be used in the middle or beginning, e.g.: c*t would match cat, caught and ct *2 would match age2, gender2 and salary2012. Alternatively, if the variables we want to include are next to each other in the data (e.g. in the Variables window), we can refer to a list of them. If the variables in the window are a through z, alphabetically, then b-e would include b, c, d, and e. 2.6 Stata Help Stata has, hands down, the best built-in help files of any of the “Big 4” statistical software.4 Stata’s help should be your first stop for any of the following: Understanding the syntax of a command Exploring the options available for a given command Looking at examples of the command in use Understanding the theoretical statistics behind the command. Help can be accessed by calling help &lt;command&gt;, such as help summarize Each help page has numerous features, I will merely point out a few here. The “Title” section contains a link (in blue) to a PDF which contains the Manual, which has more detail and examples than the help file alone. The syntax section shows the basic syntax. Any part written in square brackets ([…]) are optional. The examples in the help are great but basic; the PDF help (see #1) usually has more detailed examples. We will discuss the “Stored results” in the Programming section. help can also be used to search for the appropriate command. For example, if you wanted help merging some data together, you might try running help merging merging is not a valid Stata command, so instead Stata performs a search of the help files. This search is often not great. I would recommend searching online for the appropriate command to use (just search “Stata” and what you are trying to do), then using the built-in help for details on using the command. Finally, help help works and brings up some more information on the help command. 2.6.1 Short commands You’ll frequently see commands with partial underlining; for example summarize has the “su” underlined. Only the underlined part needs to be given for Stata to understand the command; e.g. the following are all equivalent: summarize summ su This is often true for options as well; detail (to report far more summary details) has the “d” underlined. So these are equivalent: summarize, detail su, detail summarize, d su, d The short commands are very useful for quickly writing commands, but not so great at reading them. If you came across someone else’s Stata Do-file and saw su, d, you might have trouble figuring that out unless you already knew that short command. Thankfully, the short commands can be used with help, so help su will bring up the full summarize documentation. 2.7 set more off Stata has an option, more, which, if a command were to produce voluminous output, breaks the output into “pages” so that you can see it page-by-page. Through Stata 14, the default was that this was on. Starting with Stata 15, the default is off. You can turn this on or off, set more on set more off This settings will only last as long as Stata is open. To make the change persist, use the permanently options: set more on, permanently set more off, permanently 2.8 Working directory We mentioned earlier the notion of a “working directory”, the current one you can see in the bottom left of the Stata window. You can think of a working directory as an open folder inside Windows Explorer (or Finder if you’re on a Mac). You can easily access any file within that folder without any additional trouble. You can access files in other folders (directories), but it requires moving to that folder. In the same sense, when referring to files, any file in the working directory can be referred to buy its name. For example, to open a file (we’ll go into detail about doing this later) named “mydata.dta” which is in your current working directory, you need only enter use mydata.dta If you were in a different working directory, you need to specify the full path to the file: use C:\\Documents\\Stata\\Project\\mydata.dta Similarly, when saving files, the working directory is the default choice. The working directory can be viewed with the pwd command (Print Working Directory) . pwd /Users/josh/repositories/workshops/stata-intro-book You can change the working directory by passing a path to cd (Change Directory): cd C:\\Documents\\Stata\\Project Alternatively and perhaps more easily, you can change the working directory by the menus, choosing “Files -&gt; Change working directory”. After selecting the appropriate directory, the full cd command will be printed in the Results, so you can save it in a Do-file for later use. 2.8.1 File paths There are some distinctions between Windows and Mac in regards to file paths, the most blatant that Windows uses forward slash (\\) whereas Mac uses back slashes (/). You can see full details of this by running help filename. Technically Stata can run commands prefaced by ., but it’s considered inappropriate.↩ This course does not cover fitting statistical models↩ This is the reason why * as a comment does not work in the middle of a line (and we use // instead).↩ I consider the “Big 4” as Stata, SAS, SPSS, and R. Both SAS and SPSS have terrible help; R’s is very hit-or-miss.↩ "],
["working-with-data-sets.html", "Chapter 3 Working with Data Sets 3.1 Built-in data 3.2 Opening data 3.3 Saving data 3.4 preserve/restore 3.5 Exercise 1", " Chapter 3 Working with Data Sets 3.1 Built-in data Before we turn to using your own data, it is useful to know that Stata comes with a collection of sample data sets which you can use to try the Stata commands. Additionally, most (if not all) of the examples in Stata help will use these data sets. To see a list of the built-in data sets, use . sysuse dir RDSL.subset.dta census.dta network1a.dta tsline1.dta auto.dta citytemp.dta nlsw88.dta tsline2.dta auto2.dta citytemp4.dta nlswide1.dta uslifeexp.dta autornd.dta educ99gdp.dta pop2000.dta uslifeexp2.dta bplong.dta gnp96.dta sandstone.dta voter.dta bpwide.dta lifeexp.dta sp500.dta xtline1.dta cancer.dta network1.dta surface.dta and use sysuse again to load data, for example the auto data which contains characteristics of various cars from a 1978 Consumer’s Report magazine. . sysuse auto (1978 Automobile Data) If you make any modifications to your data, Stata will try and protect you by refusing to load a new data set which would dispose of your changes. If you are willing to dispose of your changes, you can either manually do it by calling clear or passing it as an option to sysuse, . sysuse auto, clear (1978 Automobile Data) 3.2 Opening data As you may have guessed from the sysuse command above, the command to load local data is use: use &lt;filename&gt; As discussed in the working directory section, Stata can see only files in its working directory, so only the name of the file needs to be passed. If the file exists in a different directory, you will need to give the full (or relative path). For example, if your working directory is “C:” and the file you are looking for, “mydata.dta”, is in the “Project” subfolder, you could open it with any of the following: use C:\\Documents\\Stata\\Project\\mydata.dta use Project\\mydata.dta cd Documents\\Stata\\Project use mydata.dta Note that if the path (or file name) contains any spaces, you need to wrap the entire thing in quotes: use &quot;C:\\Documents\\Stata\\My Project\\My Data&quot; It is never wrong to use quotes (just not always required), so perhaps that’s a safer option. If the location of your file is much different than your working directory, it can be quicker just to use the menu “File -&gt; Open” and use the file open dialog box instead. As with all commands, the use command will be echoed in the Results after using the dialog box, allowing you to add it to a Do-file. As with sysuse, the clear option discards the existing data regardless of unsaved changes. 3.3 Saving data The save command can be used to save a data set. Without any further arguments, it saves the existing file with the same name. save However, Stata again tries to save you from yourself and does not allow you to overwrite an existing file, so you’ll basically never run save by itself. Instead, passing the replace option allows you to overwrite existing files: save, replace Finally, we can pass a name to the command to save a file with a different name: save mynewdata.dta This can also take a replace option. save follows the same logic as use with regards to the working directory; it saves in the working directory unless you pass a path. Additionally, a file name with spaces needs to be wrapped in quotes. The File -&gt; Save (and Save As) menu options can be used instead. System data (loaded with sysuse) can only be saved as a new file; you cannot (easily) modify the built-in data.q 3.4 preserve/restore Along with the One Data principal, if you wished to modify a data set temporarily, say to remove some subset of your observations, it must be done destructively. One workflow to use would be: sysuse auto &lt;modify data set as desired&gt; save tmp &lt;subset data&gt; &lt;obtain results&gt; use tmp, clear &lt;delete the tmp file manually&gt; Alternatively, the preserve and restore commands perform the same set of operations in a more automated fashion: sysuse auto &lt;modify data set as desired&gt; preserve &lt;subset data&gt; &lt;obtain results&gt; restore The preserve command saves an image of the data as they are now, and the restore command reloads the image of the data, discarding any interim changes. There can only be a single image of the data preserved at a time, so if you preserve, then make a change and want to preserve again (without an intervening restore), you’ll need to desroy the existing preserved state by passing the option not to restore. restore, not 3.5 Exercise 1 You can access the file you’ll be working with in this class here: RDSL.subset.dta. Download the data and move it into your M drive. Open the data with Stata (either double click on the file, or use File -&gt; Open, or use use). Use pwd to ensure that directory containing the data file is the working directory. If not, use File -&gt; Change Working Directory or cd to fix it. "],
["data-management.html", "Chapter 4 Data Management 4.1 describe 4.2 Labels 4.3 Managing variables 4.4 Summarizing the data 4.5 Exercise 2", " Chapter 4 Data Management Throughout this chapter, we’ll be using the “auto” data set which is distributed with Stata. It can be loaded via . sysuse auto, clear (1978 Automobile Data) You can reload it as necessary (if you modify it and want the original) by re-running this whenever you want. Whenever you first begin working with a data set, you’ll want to spend some time getting familiar with it. You should be able to answer the following questions (even if some of them are approximations): How many observations does your data have? How many variables are in your data set? What is the unit of analysis? (What does each row represent - a person? a couple? a classroom?) Is there a variable which uniquely identifies each unit of analysis? If the data is repeated measures in some form (multiple rows per person, or data is students across several classrooms), what variable(s) identify the levels and groups? Are there any variables which are strings (non-numeric) that you plan on using in some statistical analysis (and will need to be converted to numeric)? Which variables are continuous (can take on any value in some reasonable range, such as weight) vs which are categorical (take on a set number of values where each represents something). You’ll notice that there are no statistical questions here - we’re not even worried about those yet! These are merely logistical. In this chapter we’ll go over various tools and commands you can use to answer these questions (and more) and overall to gain a familiarity with the logistics of your data. 4.1 describe The first command you should run is describe. . describe Contains data from /Applications/Stata/ado/base/a/auto.dta obs: 74 1978 Automobile Data vars: 12 13 Apr 2016 17:45 size: 3,182 (_dta has notes) ------------------------------------------------------------------------------- storage display value variable name type format label variable label ------------------------------------------------------------------------------- make str18 %-18s Make and Model price int %8.0gc Price mpg int %8.0g Mileage (mpg) rep78 int %8.0g Repair Record 1978 headroom float %6.1f Headroom (in.) trunk int %8.0g Trunk space (cu. ft.) weight int %8.0gc Weight (lbs.) length int %8.0g Length (in.) turn int %8.0g Turn Circle (ft.) displacement int %8.0g Displacement (cu. in.) gear_ratio float %6.2f Gear Ratio foreign byte %8.0g origin Car type ------------------------------------------------------------------------------- Sorted by: foreign This displays a large amount of information, so let’s break in down. First, the header displays general data set information - the number of observations (obs, the number of rows) and variables (vars), as well as the file size5 It also gives a short label of the data, the date of last modification and whether there are any notes. Next, there is a table listing each variable in the data and some information about them. The “storage type” can be one of byte, int, long, float, double; all of which are simply numbers. There are some distinctions between them, but for our purposes they are irrelevant6. String variables are represented as str## where the ## represent the number of characters that the string can be, e.g. str18 shows that make has a maximum of 18 letters. This limit is actually irrelevant; if you add a new string that is longer (or modify an existing one), Stata will simply increase str## as needed. The “display format” column contains format information about each variable which only control how the variables are displayed in data view. For the most part you can ignore these and leave them at the default, though you may need to work with this if you have date or time information. For further details see help formats “value label” and “variable label” are used to display more information when running analyses using these variables. See the label section for further details. Finally, if the data is sorted, describe will provide information about the sorting. describe can also be used on a per variable basis: . describe mpg storage display value variable name type format label variable label ------------------------------------------------------------------------------- mpg int %8.0g Mileage (mpg) . describe rep78-turn storage display value variable name type format label variable label ------------------------------------------------------------------------------- rep78 int %8.0g Repair Record 1978 headroom float %6.1f Headroom (in.) trunk int %8.0g Trunk space (cu. ft.) weight int %8.0gc Weight (lbs.) length int %8.0g Length (in.) turn int %8.0g Turn Circle (ft.) If you have a very large number of variables you may wish to suppress the table of variables entirely: . describe, short Contains data from /Applications/Stata/ado/base/a/auto.dta obs: 74 1978 Automobile Data vars: 12 13 Apr 2016 17:45 size: 3,182 Sorted by: foreign Alternatively, the simple option returns only the names of the variables, in column-dominant order (meaning you read down the columns not across the rows). . describe, simple make rep78 weight displacement price headroom length gear_ratio mpg trunk turn foreign 4.2 Labels A raw data set is very sparse on context. In addition to the data itself, it will have at most a variable name, which in Stata cannot include spaces and is limited to 32 characters. All other context associated with the data must either be documented in a data dictionary or exist in the recollection of the analyst. In an Excel file, to get around this, you might add additional content to the sheet outside of the raw data - a note here, a subtitle there, etc. However, Stata does not allow such arbitrary storage. In contrast, Stata allows you to directly label parts of the data with context information which will be displayed in the appropriate Results, to make Stata output much easier to read as well as removing the need for an external data dictionary. All three different versions use the label command. 4.2.1 label variable Variables names, as mentioned, are limited to 32 characters and do not allow spaces (or several other special characters). This is to encourage you to choose short, simple, and memorable variable names, since you’ll likely be typing them a lot! We can easily add more information with a variable label. If you look at the describe output, you’ll notice that the auto data set already has variable labels applied to it. . describe Contains data from /Applications/Stata/ado/base/a/auto.dta obs: 74 1978 Automobile Data vars: 12 13 Apr 2016 17:45 size: 3,182 (_dta has notes) ------------------------------------------------------------------------------- storage display value variable name type format label variable label ------------------------------------------------------------------------------- make str18 %-18s Make and Model price int %8.0gc Price mpg int %8.0g Mileage (mpg) rep78 int %8.0g Repair Record 1978 headroom float %6.1f Headroom (in.) trunk int %8.0g Trunk space (cu. ft.) weight int %8.0gc Weight (lbs.) length int %8.0g Length (in.) turn int %8.0g Turn Circle (ft.) displacement int %8.0g Displacement (cu. in.) gear_ratio float %6.2f Gear Ratio foreign byte %8.0g origin Car type ------------------------------------------------------------------------------- Sorted by: foreign We can see variable rep78 (an utterly incomprehensible name at first glance, as opposed to mpg) has the label “Repair Record 1978”. You can apply your own variable labels (or overwrite existing by using the command: label variable &lt;variable name&gt; &quot;Variable label&quot; For example: . label variable turn &quot;Some new label for turn&quot; . describe turn storage display value variable name type format label variable label ------------------------------------------------------------------------------- turn int %8.0g Some new label for turn 4.2.2 label values It is tempting to store categorical variables as strings. If you ask, for example, for someone’s state of residence, you might store the answers as “MI”, “OH”, “FL”, etc. However, Stata (like most statistical software) cannot handle string variables.7 A much better way to store this data would be to assign each state a numerical value, say MI = 1, OH = 2, FL = 3, etc, then keep a data dictionary linking the values to the labels they represent. Stata allows you to store this value labels information within the data set, such that whenever the values are output, the labels are printed instead. Let’s take a look at the foreign variable. This variable takes on two levels, and we can tabulate it to see how many cars are in each category. . tab foreign Car type | Freq. Percent Cum. ------------+----------------------------------- Domestic | 52 70.27 70.27 Foreign | 22 29.73 100.00 ------------+----------------------------------- Total | 74 100.00 Here it appears that foreign is stored as two strings, but we know from describe that it is not: . describe foreign storage display value variable name type format label variable label ------------------------------------------------------------------------------- foreign byte %8.0g origin Car type Instead, let’s look at that table ignoring the value labels: . tab foreign, nolabel Car type | Freq. Percent Cum. ------------+----------------------------------- 0 | 52 70.27 70.27 1 | 22 29.73 100.00 ------------+----------------------------------- Total | 74 100.00 Now we see the values which are actually stored. Look at the describe output: . describe foreign storage display value variable name type format label variable label ------------------------------------------------------------------------------- foreign byte %8.0g origin Car type You’ll notice that in the “value label” column has origin attached to foreign. In Stata, the value labels information are stored separately from the variables. They are two separate components - there is a variable and there is a value label. You connect the value label to a variable to use it. The benefit of this separated structure is that if you have several variables which have the same coding scheme (e.g. a series of Likert scale questions, where 1-5 represents “Strongly Disagree”-“Strongly Agree”), you can create a single value label and rapidly apply it to all variables necessary. Correspondingly, this process requires two commands. First we define the value labels: label define &lt;label name&gt; &lt;value&gt; &quot;&lt;label&gt;&quot; &lt;value&gt; &quot;&lt;label&gt;&quot; ..... For example, if we wanted to recreate the value label associated with foreign: . label define foreign_label 0 &quot;Domestic&quot; 1 &quot;Foreign&quot; Value labels exist in the data set, regardless of whether they are attached to any variables, we can see all value labels: . label list foreign_label: 0 Domestic 1 Foreign origin: 0 Domestic 1 Foreign Here we see the original origin as well as our new foreign_label. To attach it to the variable foreign: . label values foreign foreign_label If we wanted to attach a single value label to multiple variables, we could simply provide a list of variables: label values &lt;var1&gt; &lt;var2&gt; &lt;var3&gt; &lt;label&gt; To remove the value labels from a variable, use the label values command with no label name following the variable name: . label values foreign . describe foreign storage display value variable name type format label variable label ------------------------------------------------------------------------------- foreign byte %8.0g Car type Note that value labels exist within a data set regardless of whether they are attached to a variable. If there is a label value that you no longer want to keep in the data-set, you can drop it: . label drop foreign_label . label list origin: 0 Domestic 1 Foreign This will not remove the value labels from any variables, but they will no longer be active (i.e. if you run describe it will still show that the value labels are attached, but running tab will not use them). So in order to completely remove a value label, you’ll need to both remove it from the variable as well as the data. Do not forget that modifying value labels counts as modifying the data. Make sure you save, replace after making these modifications (if you want to keep them) or they’ll be lost! 4.3 Managing variables In Stata, managing the names and order of variables is important to make entering commands easier due to the shortcuts for referring to variables. Recall that variables can be referred to using wildcards (e.g. a* to include age, address or a10, or using var1-var10 to include all variables between var1 and var10 as they are ordered). Of course, you may also want to rename or re-order variables for other reasons such as making the data easier to look at. To rename variables: rename &lt;oldname&gt; &lt;newname&gt; For example: . rename rep78 repair_record_1978 . describe, simple make repair_~1978 weight displacement price headroom length gear_ratio mpg trunk turn foreign The output truncated the name because it was so long, but the full name exists in the data. To rename multiple variables, you can run multiple rename commands, or else you can give multiple old and new names: . rename (mpg trunk turn) (mpg2 trunk2 turn2) . describe, simple make repair_~1978 weight displacement price headroom length gear_ratio mpg2 trunk2 turn2 foreign The first old variable is renamed to the first new variable, the second to the second, etc. The parentheses are required. Variable names are unique; if you wanted to swap to variable names, you’d have to name one to a temporary name, rename the second, then rename the first again. Alternately, you can do it simultaneously: rename (var1 var2) (var2 var1) You can use wildcards in the renaming too. For example, imagine you had a collection of variables from a longitudinal data set, “visit1_age”, “visit1_weight”, “visit1_height”, etc. To simplify variable names, we’d prefer to use “age1”, “weight1”, etc. rename visit1_* *1 Finally, you can change a variable name to upper/lower/proper case easily by passing upper/lower/proper as an argument and giving no new variable name. . rename length, upper . describe, simple make repair_~1978 weight displacement price headroom LENGTH gear_ratio mpg2 trunk2 turn2 foreign Turning to variable ordering, the order command takes a list of variables and moves them to the front/end/before a certain variable/after a certain variable. The options first, last, before(&lt;variable&gt;) and after(&lt;variable&gt;) control this. . order foreign // The default is `first` . describe, simple foreign mpg2 trunk2 turn2 make repair_~1978 weight displacement price headroom LENGTH gear_ratio . order weight, last . describe, simple foreign mpg2 trunk2 displacement make repair_~1978 LENGTH gear_ratio price headroom turn2 weight . order mpg2 trunk2, before(displacement) . describe, simple foreign repair_~1978 turn2 displacement make headroom mpg2 gear_ratio price LENGTH trunk2 weight 4.4 Summarizing the data While these notes will not cover anything statistical, it can be handy from a data management perspective to look at some summary statistics, mostly to identify problematic variables. Among other things, we can try and detect Unexpectedly missing data Incorrectly coded data Errors/typos in input data Incorrect assumptions about variable values There are numerous ways to look at summary statistics, from obtaining one-number summaries to visualizations, but we will focus on two Stata commands, summarize and codebook. summarize produces basic summary statistics for numeric variables. . summarize Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- foreign | 74 .2972973 .4601885 0 1 make | 0 price | 74 6165.257 2949.496 3291 15906 repair_~1978 | 69 3.405797 .9899323 1 5 headroom | 74 2.993243 .8459948 1.5 5 -------------+--------------------------------------------------------- LENGTH | 74 187.9324 22.26634 142 233 turn2 | 74 39.64865 4.399354 31 51 mpg2 | 74 21.2973 5.785503 12 41 trunk2 | 74 13.75676 4.277404 5 23 displacement | 74 197.2973 91.83722 79 425 -------------+--------------------------------------------------------- gear_ratio | 74 3.014865 .4562871 2.19 3.89 weight | 74 3019.459 777.1936 1760 4840 The table reports the total number of non-missing values (make appears to be entirely missing because it is non-numeric), the mean (the average value), the standard deviation (a measure of how spread out the data is) and the minimum and maximum non-missing8 values observed. Here’s some suggestions of how to look at these values. Make sure the amount of missing data is expected. If the number of observations is lower than anticipated, is it an issue with the data collection? Or did the import into Stata cause issues? 5 cars have no repair_record_1978. The mean should be a reasonable number, somewhere in the rough middle of the range of possible values for the variable. If you have age recorded for a random selection of adults and the mean age is 18, something has gone wrong. If the mean age is -18, something has gone tragically wrong! The standard deviation is hard to interpret precisely, but in a very rough sense, 2/3rds of the values should lie within 1 standard deviation of the mean. For example, consider mpg2. The mean is ~21 and the standard deviation is ~6, so roughly 2/3rds of the cars have mpg2 between 15 and 27. Does this seems reasonable? If the standard deviation is very high compared to the mean (e.g. if mpg2’s standard deviation was 50) or close to 0, that could indicate an issue. Are the max and min reasonable? If the minimum LENGTH was -9, that’s problematic. Maybe -9 is the code for missing values? If the range of LENGTH is 14 to 2500, maybe the units differ? They measured in feet for some cars and inches for others? summarize can also take a list of variables, e.g. . summarize t* Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- turn2 | 74 39.64865 4.399354 31 51 trunk2 | 74 13.75676 4.277404 5 23 For more detailed information, we can look at the codebook. codebook works similarly to describe and summarize in the sense that without any additional arguments, it displays information on every variable; you can pass it a list of variables to only operate on those. Because codebook’s output is quite long, we only demonstrate the restricted version. Before we do that, we reload the “auto” data because we messed with it quite a bit earlier! First, categorical data: . sysuse auto, clear (1978 Automobile Data) . codebook rep78 ------------------------------------------------------------------------------- rep78 Repair Record 1978 ------------------------------------------------------------------------------- type: numeric (int) range: [1,5] units: 1 unique values: 5 missing .: 5/74 tabulation: Freq. Value 2 1 8 2 30 3 18 4 11 5 5 . We see that rep78 takes on six unique values (Up to 5 repairs, plus the missing data represented by .). If the unique values is more than expected, it’s something to investigate. Next, continuous variables: . codebook price ------------------------------------------------------------------------------- price Price ------------------------------------------------------------------------------- type: numeric (int) range: [3291,15906] units: 1 unique values: 74 missing .: 0/74 mean: 6165.26 std. dev: 2949.5 percentiles: 10% 25% 50% 75% 90% 3895 4195 5006.5 6342 11385 We still see the number of unique values reported, but here every observation has a unique value (74 unique values, 74 rows in the data). There is no missing data. The percentiles should be checked to see if they’re reasonable, if 90% of the cars had a price under $100, something’s not right. Finally, string variables: . codebook make ------------------------------------------------------------------------------- make Make and Model ------------------------------------------------------------------------------- type: string (str18), but longest is str17 unique values: 74 missing &quot;&quot;: 0/74 examples: &quot;Cad. Deville&quot; &quot;Dodge Magnum&quot; &quot;Merc. XR-7&quot; &quot;Pont. Catalina&quot; warning: variable has embedded blanks We get less information here, but still useful to check that the data is as expected. There are no empty strings nor any repeated strings. The warning about “embedded blanks” is spaces; it’s telling us that there are spaces in some of the cars (e.g. “Dodge Magnum”). The reason it is a warning is that “Dodge Magnum” and “Dodge Magnum” looks the same to us, but Stata notices that the second actually has two spaces, so considers these completely unique strings. Two options for codebook which come in handy: . codebook, compact Variable Obs Unique Mean Min Max Label ------------------------------------------------------------------------------- make 74 74 . . . Make and Model price 74 74 6165.257 3291 15906 Price mpg 74 21 21.2973 12 41 Mileage (mpg) rep78 69 5 3.405797 1 5 Repair Record 1978 headroom 74 8 2.993243 1.5 5 Headroom (in.) trunk 74 18 13.75676 5 23 Trunk space (cu. ft.) weight 74 64 3019.459 1760 4840 Weight (lbs.) length 74 47 187.9324 142 233 Length (in.) turn 74 18 39.64865 31 51 Turn Circle (ft.) displacement 74 31 197.2973 79 425 Displacement (cu. in.) gear_ratio 74 36 3.014865 2.19 3.89 Gear Ratio foreign 74 2 .2972973 0 1 Car type ------------------------------------------------------------------------------- compact shows a reduced size version, most useful for the “Unique” column. (Useful if that’s the only thing you’re running the codebook for.) . codebook, problems Potential problems in dataset /Applications/Stata/ado/base/a/auto.dta potential problem variables -------------------------------------------------- str# vars that may be compressed make string vars with embedded blanks make -------------------------------------------------- This reports potential issues Stata has discovered in the data. In this data, neither are really concerns (We can run compress, but this isn’t a “problem” so much as a suggestion. We already saw above the concern about “embedded blanks.”) More serious problems that it can detect include: Constant columns (all entries being the same value, including all missing). Issues with value labels (if you’ve attached a value label to a variable and subsequently deleted the value label without detaching it; or if your variable takes on values unaccounted for in the value label). Issues with date variables. 4.5 Exercise 2 If you haven’t already, open the “RDSL.subset” data. Begin by exploring the data generally with describe, summarize and codebook. After you’ve explored a bit, look into answering the following questions: What variables are continuous? Binary? Categorical? Most of the gpa data (hsgpa) are values like 2.9 or 3.8. There are several rows with the values 2.5364995. Does anything in the data tell you why? Run label list FCPREVPG to look at the labels being applied to bcprevpg. There is only one label! Why might that be? Reported in bytes. Roughly 1000 bytes = 1 kilobyte, 1000 kilobytes = 1 megabyte, 1000 megabytes = 1 gigabyte.↩ They are irrelevant mostly because Stata will adjust them according to our need; so we don’t concern ourselves with it↩ In the few situations where it can, it doesn’t handle them cleanly.↩ As we discuss later, in Stata, missing values (represented by . in the data) are considered to be higher than any other number (so 99999 &lt; .).↩ "],
["data-manipulation.html", "Chapter 5 Data Manipulation 5.1 generate 5.2 replace 5.3 Missing values 5.4 Subsetting 5.5 Sorting 5.6 Exercise 3", " Chapter 5 Data Manipulation Let’s reload the “auto” data to discard any changes made in previous sections and to start fresh. . sysuse auto, clear (1978 Automobile Data) 5.1 generate The generate command can be used to create new variables which are functions of existing variables. For example, if we look at the variable label for weight, we see that it is measured in pounds. . describe weight storage display value variable name type format label variable label ------------------------------------------------------------------------------- weight int %8.0gc Weight (lbs.) Let’s create a second weight variable measured in tons. The syntax for generate is straightforward, generate &lt;new varname&gt; = &lt;function of old variables&gt; . generate weight2 = weight/2000 The list command can be used to output some data, let’s use it here to output the first 5 rows’ weight and weight2 variables: . list weight* in 1/5 +------------------+ | weight weight2 | |------------------| 1. | 2,930 1.465 | 2. | 3,350 1.675 | 3. | 2,640 1.32 | 4. | 3,250 1.625 | 5. | 4,080 2.04 | +------------------+ If you check the arithmetic, you’ll see that we’ve got the right answer. We should probably add a variable label to our new weight . label variable weight2 &quot;Weight (tons)&quot; . describe weight* storage display value variable name type format label variable label ------------------------------------------------------------------------------- weight int %8.0gc Weight (lbs.) weight2 float %9.0g Weight (tons) In addition to direct arithmetic equations, we can use a number of functions to perform calculations. For example, a common transformation is to take the log of any dollar amount variable, in our case price. This is done because typical dollar amount variables, such as price or salary, tend to be very right-skewed - most people make $30k-50k, and a few people make 6 or 7 digit incomes. . generate logprice = log(price) . label variable logprice &quot;Log price&quot; . list *price in 1/5 +------------------+ | price logprice | |------------------| 1. | 4,099 8.318499 | 2. | 4,749 8.46569 | 3. | 3,799 8.242494 | 4. | 4,816 8.479699 | 5. | 7,827 8.965335 | +------------------+ In that command, log is the function name, and it is immediately followed by parentheses which enclose the variable to operate on. Read the parentheses as “of”, so that log(price) is read as “log of price”. There are a lot of functions that can be used. We list some commonly used mathematical functions below for your convenience: +, -, *, /: Standard arithmetic abs( ): returns the absolute value exp( ): returns the exponential function of (e^x) log( ) or ln( ): returns the natural logarithm of the argument round( ): returns the rounded value sqrt( ): returns the square root Stata also offers functions for string variables, such as: length( ): returns the length of the string lower( ): returns the string in lower-case letters ltrim( ): returns the string with any leading spaces stripped rtrim( ): returns the string with any trailing spaces stripped string( ): converts a numeric value to a string value upper( ): returns the string in upper-case letters You can see a full accounting of all functions you can use in this setting in help functions 5.1.1 Extension to generate The command egen offers some functionality that generate lacks, for example creating the mean of several variables egen &lt;newvar&gt; = rowmean(var1, var2, var3) The functions which egen support are fairly esoteric; you can see the full list in the help: help egen 5.2 replace Earlier we created the weight2 variable which changed the units on weight from pounds to tons. What if, instead of creating a new variable, we tried to just change the existing weight variable. . generate weight = weight/2000 variable weight already defined r(110); Here Stata refuses to proceed since weight is already defined. To overwrite weight, we’ll instead need to use the replace command. . replace weight = weight/2000 variable weight was int now float (74 real changes made) . list weight in 1/5 +--------+ | weight | |--------| 1. | 1.465 | 2. | 1.675 | 3. | 1.32 | 4. | 1.625 | 5. | 2.04 | +--------+ replace features syntax identical to generate.9 5.2.1 Conditional variable generation One frequent task is recoding variables. This can be “binning” continuous variables into a few categories, re-ordering an ordinal variables, or collapsing categories in an already-categorical variable. There are also multi-variable versions; e.g. combining multiple variables into one. The general workflow with these cases will be to optionally use generate to create the new variable, then use replace to conditional replace the original or new variable. As a first example, let’s collapse the rep78 variable into a low/mid/high cost of maintenance categorical variable (1 repair, 2-3 repairs, 4-5 repairs). First, we’ll generate the new variable. . generate cost_maint = 1 . tab cost_maint cost_maint | Freq. Percent Cum. ------------+----------------------------------- 1 | 74 100.00 100.00 ------------+----------------------------------- Total | 74 100.00 Without any variables or conditions, every row is set to 1. We’ll let the 1 represent the “low” category, so next we’ll replace it with 2 for cars in the “mid” category. . replace cost_maint = 2 if rep78 &gt;= 2 &amp; rep78 &lt;= 3 (38 real changes made) . tab cost_maint cost_maint | Freq. Percent Cum. ------------+----------------------------------- 1 | 36 48.65 48.65 2 | 38 51.35 100.00 ------------+----------------------------------- Total | 74 100.00 The &amp; is an “and”; the statement if rep78 &gt;= 2 &amp; rep78 &lt;= 3 returns either true or false; true only if both rep78 &gt;= 2 and rep78 &lt;= 3 are true. Alternatively, we could have used if rep78 == 2 | rep78 == 3, where | means “or” and the double equals is testing equality; the statement returns true if rep78 is identically equal to 2 or 3. Finish with the “high” category. . replace cost_maint = 3 if rep78 &gt; 3 (34 real changes made) . tab cost_maint cost_maint | Freq. Percent Cum. ------------+----------------------------------- 1 | 2 2.70 2.70 2 | 38 51.35 54.05 3 | 34 45.95 100.00 ------------+----------------------------------- Total | 74 100.00 There’s one additional complication. Stata represents missing values by ., and . has a value of positive infinity. That means that \\[ 400 \\lt . \\] is true! There is some discussion on the Stata FAQs that goes into the rationale behind it, but the short version is that this slightly complicates variable generation but greatly simplifies and protects data management tasks. The complication referred to can be seen in row 3 here: . list make rep78 cost_maint in 1/5, abbr(100) +------------------------------------+ | make rep78 cost_maint | |------------------------------------| 1. | AMC Concord 3 2 | 2. | AMC Pacer 3 2 | 3. | AMC Spirit . 3 | 4. | Buick Century 3 2 | 5. | Buick Electra 4 3 | +------------------------------------+ (The abbr option changes the number of displayed characters for string variables, I set it to a large value here so the whole make can be seen.) The AMC Spirit has a high repair cost even though we do not have its repair record. We can fix this easily. . replace cost_maint = rep78 if rep78 &gt;= . (5 real changes made, 5 to missing) . tab cost_maint, missing cost_maint | Freq. Percent Cum. ------------+----------------------------------- 1 | 2 2.70 2.70 2 | 38 51.35 54.05 3 | 29 39.19 93.24 . | 5 6.76 100.00 ------------+----------------------------------- Total | 74 100.00 The missing option to tab forces it to show a row for any missing values. Without it, missing rows are suppressed. Perhaps a more natural way to do the above replacement would be replace cost_maint = . if rep78 == . In other words, if rep78 is missing, make cost_maint missing. Instead, the version run above says, if rep78 is missing or larger, replace cost_maint with rep78. See below for further explanation of this. To summarize, we used the following commands: generate cost_maint = 1 replace cost_maint = 2 if rep78 &gt;= 2 &amp; rep78 &lt;= 3 replace cost_maint = 3 if rep78 &gt; 3 replace cost_maint = rep78 if rep78 &gt;= . There are various other ways it could have been done, such as: generate cost_maint = 1 if rep78 == 1 replace cost_maint = 2 if rep78 &gt;= 2 &amp; rep78 &lt;= 3 replace cost_maint = 3 if rep78 &gt; 3 &amp; rep78 &lt; . replace cost_maint = rep78 if rep78 &gt;= . generate cost_maint = rep78 replace cost_maint = 1 if rep78 == 1 replace cost_maint = 2 if rep78 &gt;= 2 &amp; rep78 &lt;= 3 replace cost_maint = 3 if rep78 &gt; 3 &amp; rep78 &lt; . Of course, we could also generate it in the reverse order (3 to 1). 5.3 Missing values As we mentioned briefly earlier, Stata treats missing values as large positive numbers. In fact, Stata actually supports 27 different missing values, ., .a, .b, …, .z. This is to allow granularity in the reason for missingness; for example, perhaps you can code that . is random missingness (e.g. coffee spilled on a paper survey and blotted out an answer), while .r is for missingness due to refusal to answer and .n is for nonresponse. These missing values are ordered as expected, such that: . &lt; .a &lt; .b &lt; ... &lt; .z That means that a logical statement such as variable &lt; .f will return true if variable is . or .c, but false if variable is .k and .v (and of course for all other ._’s as appropriate). This is why, above, we used replace cost_maint = rep78 if rep78 &gt;= . The conditional, rep78 &gt;= ., catches both . and all .a, .b, etc, because all are greater than .. Once we’ve identified which rows contain rep78 with some missing flag, we replace cost_maint with rep78 to maintain the proper distinction between types of missingness; if we didn’t care about those in cost_maint, we could have used replace cost_maint = . instead. Stata has a shortcut to testing missingness that avoids worrying about the order, using the missing or mi function. We could have written: replace cost_maint = rep78 if missing(rep78) replace cost_maint = rep78 if mi(rep78) To check for non-missing values, use !mi(rep78) (the ! is a negation; whatever the expression to the right of it returns (true or false), it switches to the opposte). Note that when running (most) statistical analyses, Stata will ignore the differentiation between types of missingness and instead use casewise (drop any row containing any missingness in variables involved in the analysis) or pairwise (consider each pair of variables; drop a row’s pair if either is missing). 5.4 Subsetting Almost any Stata command which operates on variables can operate on a subset of the data instead of the entire data, using the conditional statements we just learned. Specifically, we can append the if &lt;condition&gt; to a command, and the command will be executed as if the data for which the conditional does not return True does not exist. This is equivalent to throwing away some data and then performing the command. In general, you should avoid discarding data as you never know when you will possible use it. Of course, you could use preserve and restore to temporarily remove the data, but using the conditional subsetting is more straightforward. . summ price Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 74 6165.257 2949.496 3291 15906 This gives us a summary of price across all cars. What if we wanted to look at the summary only for non-foreign cars? . tab foreign Car type | Freq. Percent Cum. ------------+----------------------------------- Domestic | 52 70.27 70.27 Foreign | 22 29.73 100.00 ------------+----------------------------------- Total | 74 100.00 . summ price if foreign == 0 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 52 6072.423 3097.104 3291 15906 First, we check the label to make sure we’re looking at the appropriate value of foreign. Now, notice that “Obs”, the number of rows of the data, is only 52 as we expect! If we look also at foreign cars, . summ price if foreign == 1 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 22 6384.682 2621.915 3748 12990 we see that American cars are cheaper on average10. 5.4.1 by and bysort To look at the average price for American and foreign cars, we ran two individual commands. If we wanted to look at the summaries by rep78, that would take 6 commands (values 1 through 5 and .)! Instead, we can use by and bysort to perform the same operation over each unique value in a variable. For example, we could repeat the above with: . by foreign: summ price ------------------------------------------------------------------------------- -&gt; foreign = Domestic Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 52 6072.423 3097.104 3291 15906 ------------------------------------------------------------------------------- -&gt; foreign = Foreign Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 22 6384.682 2621.915 3748 12990 There is a strong assumption here that foreign is already sorted. If foreign were not sorted (or if you simply did not want to check/assume it was), you could instead use bysort foreign: summ price bysort is identical to sorting first and running the by statement afterwards. In general, it is recommended to always use bysort instead of by, unless you believe the data is already sorted and want an error if that assumption is violated. Note that sorting does change the order of the variables, you may want to save or preserve the data beforehand so you can return to the original sorting easily. bysort’s variables cannot be conditional statements, so if you wanted to for example get summaries by low and high mileage cars, you’d need to generate a dummy variable first. . gen highmileage = mpg &gt; 20 . bysort highmileage: summ price ------------------------------------------------------------------------------- -&gt; highmileage = 0 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 38 6937.316 3262.392 3291 14500 ------------------------------------------------------------------------------- -&gt; highmileage = 1 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 36 5350.306 2358.612 3299 15906 bysort can take two or more variables, and performs its commands within each unique combination of the variable. For example, . bysort foreign highmileage: summ price ------------------------------------------------------------------------------- -&gt; foreign = Domestic, highmileage = 0 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 33 6585.606 3149.214 3291 14500 ------------------------------------------------------------------------------- -&gt; foreign = Domestic, highmileage = 1 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 19 5181.105 2867.906 3299 15906 ------------------------------------------------------------------------------- -&gt; foreign = Foreign, highmileage = 0 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 5 9258.6 3369.459 5719 12990 ------------------------------------------------------------------------------- -&gt; foreign = Foreign, highmileage = 1 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 17 5539.412 1686.472 3748 9735 5.4.2 keep, drop If you do want to discard data, you can use keep or drop to do so. They each can perform on variables: keep &lt;var1&gt; &lt;var2&gt; ... drop &lt;var1&gt; &lt;var2&gt; ... or on observations: keep if &lt;conditional&gt; drop if &lt;conditional&gt; Note that these cannot be combined: . drop turn if mpg &gt; 20 invalid syntax r(198); keep removes all variables except the listed variables, or removes any row which the conditional does not return true. drop removes any listed variables, or removes any row which the conditional returns true. 5.5 Sorting We already saw sorting in the context of bysort. We can also sort as a standalone operation. As before, consider saving or preserving first. We’ll open a clean version of “auto” first: . sysuse auto, clear (1978 Automobile Data) The gsort function takes a list of variables to order by. . gsort rep78 price . list rep78 price in 1/5 +---------------+ | rep78 price | |---------------| 1. | 1 4,195 | 2. | 1 4,934 | 3. | 2 3,667 | 4. | 2 4,010 | 5. | 2 4,060 | +---------------+ Stata first sorts the data by rep78, ascending (so the lowest value is in row 1). Then within each set of rows that have a common value of rep78, it sorts by price. You can append “+” or “-” to each variable to change whether it is ascending or descending. Without a prefix, the variable is sorted ascending. . gsort +rep78 -price . list rep78 price in 1/5 +----------------+ | rep78 price | |----------------| 1. | 1 4,934 | 2. | 1 4,195 | 3. | 2 14,500 | 4. | 2 6,342 | 5. | 2 5,886 | +----------------+ Recall that missing values (.) are larger than any other values. When sorting with missing values, they follow this rule as well. If you want to treat missing values as smaller than all other values, you can pass the mfirst option to gsort. Note this does not make missingness “less than” anywhere else, only for the purposes of the current search. Sorting strings does work and it does it alphabetically. All capital letters are “less than” all lower case letters, and a blank string (“”) is the “smallest”. For example, if you have the strings “DBC”, “Daa”, “”, “EEE”, the sorted ascending order would be “”, “DBC”, “Daa”, “EEE”. The blank is first; the two strings starting with “D” are before the string “EEE”, and the upper case “B” precedes the lower case “a”. As a side note, there is an additional command, sort, which can perform sorting. It does not allow sorting in descending order, however it does allow you to conditionally sort; that is, passing something like sort &lt;varname&gt; in &lt;condition&gt; would sort only those rows for which the condition is true, the remaining rows remain in their exact same position. 5.6 Exercise 3 If you haven’t already, open the “RDSL.subset” data. (Note: Any “interpretation” or “explanation” in this exercise is for illustrative purposes only as I have no idea what the details of this data are!) Create a new variable, school_primary_focus, which attempts to represent whether someone’s primary focus is their schooling. This variable should be a binary variable with a value of 1 if the student has a GPA greater than 2.8 and is enrolled full time. The variable bage1stsex, representing age at 1st sex, has some very low values - some that are errors (e.g. 0 or 1) and some that are hopefully errors (below 7). Replace values of 0 or 1 with a missing “.”, and replace values between 2-7 with missing “.a”. Look at a table (tab) of public assistance. Compare it with the table of public assistant amongst blacks and non-blacks. Notice any relationships? generate has a few features we do not discuss which replace does not support. Namely, generate can set the type manually (instead of letting Stata choose the best type automatically), and generate can place the new variable as desired rather than using order. Clearly, neither of these features are needed for replace.↩ Note that this is not a statistical claim, we would have to do a two-sample t-test to make any statistical claim.↩ "],
["programming.html", "Chapter 6 Programming 6.1 Macros 6.2 loops 6.3 Suppressing output and errors", " Chapter 6 Programming Stata features the ability to create user-written commands. These can range from simple data manipulation commands to completely new statistical models. This is an advanced feature that not many users will need. However, there are several components of the programming capabilities which are very useful even without writing your own commands. Here we’ll discuss several. Let’s open a fresh version of “auto” . sysuse auto, clear (1978 Automobile Data) 6.1 Macros While variables stored as strings aren’t of much use to us, strings stored as other strings can be quite useful. Imagine the following scenario: You have a collection of 5 variables that you want to perform several different operations on. You might have code like this: list var1 var2 var3 var4 var5 in 1/5 summ var1 var2 var3 var4 var5 label define mylab 0 &quot;No&quot; 1 &quot;Yes&quot; label values var1 var2 var3 var4 var5 mylab duplicates list var1 var2 var3 var4 var5 This can get extremely tedious as the number of variables and commands increases. You could copy and paste a lot, but even that takes a lot of effort. Instead, we can store the list of variables (strictly speaking, the string which contains the list of variables) in a shorter key string, and refer to that instead! local vars = &quot;var1 var2 var3 var4 var5&quot; list `vars' in 1/5 summ `vars' label define mylab 0 &quot;No&quot; 1 &quot;Yes&quot; label values `vars' mylab duplicates list `vars' The first command, local, defines what is known as a “local macro”11. Whenever it is referred to, wrapped in a backtick (to the left of the 1 key at the top-left of the keyboard) and a single quote, Stata replaces it with the original text. So when you enter list `vars' in 1/5 Stata immediately replaces `vars’ with var1 var2 var3 var4 var5, then executes list var1 var2 var3 var4 var5 in 1/5 Important: Local macros which are created in Do-files are deleted as soon as code finishes executing! That means that you must use them in a do-file, and you must run all lines which create and access the macro at the same time, by highlighting them all. Some other notes: If your macro contains text that should be quoted, you still need to quote it when accessing. For example, if you had label variable price1 &quot;Price (in dollars) at Time Point 1&quot; label variable price2 &quot;Price (in dollars) at Time Point 2&quot; you could instead write local pricelab = &quot;Price (in dollars) at Time Point&quot; label variable price1 &quot;`pricelab' 1&quot; label variable price2 &quot;`pricelab' 2&quot; You can use display to print the content of macros to the output to preview them. . local test = &quot;abc&quot; . display &quot;`test'&quot; abc You may occasionally see code that excludes the = in macros. The differences between including and excluding the = are mostly unimportant, so I recommend sticking with the = unless you specifically need the other version. 6.1.1 Class and Return Every command in Stata is of a particular type. One major aspect of the type is what the command “returns”. Some commands are n-class, which means they don’t return anything. Some are c-class, which are only used by programmers and rarely useful elsewhere. The two common ones are e-class and r-class. The distinction between the two is inconsequential, besides that they store their “returns” in different places. Here, summarize is a r-class command, so it stores its returns in “return”. We can see them all by return list. On the other hand, mean (which we haven’t discussed, but basically displays summary statistics similar to summarize but provides some additional functionality) is an e-class command, storing its results in ereturn: . summ price Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 74 6165.257 2949.496 3291 15906 . return list scalars: r(N) = 74 r(sum_w) = 74 r(mean) = 6165.256756756757 r(Var) = 8699525.974268788 r(sd) = 2949.495884768919 r(min) = 3291 r(max) = 15906 r(sum) = 456229 . mean price Mean estimation Number of obs = 74 -------------------------------------------------------------- | Mean Std. Err. [95% Conf. Interval] -------------+------------------------------------------------ price | 6165.257 342.8719 5481.914 6848.6 -------------------------------------------------------------- . ereturn list scalars: e(df_r) = 73 e(N_over) = 1 e(N) = 74 e(k_eq) = 1 e(rank) = 1 macros: e(cmdline) : &quot;mean price&quot; e(cmd) : &quot;mean&quot; e(vce) : &quot;analytic&quot; e(title) : &quot;Mean estimation&quot; e(estat_cmd) : &quot;estat_vce_only&quot; e(varlist) : &quot;price&quot; e(marginsnotok) : &quot;_ALL&quot; e(properties) : &quot;b V&quot; e(depvar) : &quot;Mean&quot; matrices: e(b) : 1 x 1 e(V) : 1 x 1 e(_N) : 1 x 1 e(error) : 1 x 1 functions: e(sample) Rather than try and keep track of what gets stored where, if you look at the very bottom of any help file, it will say something like “summarize stores the following in r():” or “mean stores the following in e():”, corresponding to return and ereturn respectively. Along with the One Data principal, Stata also follows the One _-class principal - meaning you can only view the return or ereturn for the most recent command of that class. So if you run a summarize command, then do a bunch of n-class calls (gsort for example), the return list call will still give you the returns for that first summarize. However, as soon as you run another command, you lose it. You can save any piece of it using a macro. For example, to calculate the average difference in price between foreign and domestic cars12: . summ price if foreign == 1 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 22 6384.682 2621.915 3748 12990 . local fprice = r(mean) . summ price if foreign == 0 Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- price | 52 6072.423 3097.104 3291 15906 . local dprice = r(mean) . display `dprice' - `fprice' -312.25874 6.2 loops Using macros can simplify code if you have to use the same string repeatedly, but what if you want to perform the same command repeatedly with different variables? Here we can use a foreach loop. This is easiest to see with examples. . sysuse pop2000, clear The “pop2000” data contains data from the 2000 census, broken down by age and gender. The values are in total counts, lets say instead we want percentages by gender. For example, what percentage of Asians in age 25-29 are male? We could generate this manually. . gen maletotalperc = maletotal/total . gen femtotalperc = femtotal/total . gen malewhiteperc = malewhite/white This gets tedious fast as we need a total of 12 lines! Notice, however, that each line has a predictable pattern: gen &lt;gender&gt;&lt;race&gt;perc = &lt;gender&gt;&lt;race&gt;/&lt;race&gt; We can exploit this by creating a foreach loop over the racial categories and only needing a single command. . drop *perc . foreach race of varlist total-island { 2. gen male`race'perc = male`race'/`race' 3. gen fem`race'perc = fem`race'/`race' 4. } . list *perc in 1, ab(100) +---------------------------------------------------------------+ 1. | maletotalperc | femtotalperc | malewhiteperc | femwhiteperc | | .5116206 | .4883794 | .5130497 | .4869503 | |---------------+--------------+----------------+---------------| | maleblackperc | femblackperc | maleindianperc | femindianperc | | .5078017 | .4921983 | .5100116 | .4899884 | |---------------+--------------+----------------+---------------| | maleasianperc | femasianperc | maleislandperc | femislandperc | | .5029027 | .4970973 | .5167261 | .4832739 | +---------------------------------------------------------------+ Let’s breakdown each piece of the command. The command syntax for foreach is foreach &lt;new macroname&gt; of varlist &lt;list of variables&gt; The loop will create a macro that you name (in the example above, it was named “race”), and repeatedly set it to each subsequent entry in the list of variables. So in the code above, first “race” is set to “total”, then the two gen commands are run. Next, “race” is set to “white”, then the two commands are run. Etc. Within each of the gen commands, we use the backtick-quote notation just like with macros. Finally, we end the foreach line with an open curly brace, {, and the line after the last command within the loop has the matching close curly brace, }. We can also nest these loops. Notice that both gen statements above are identical except for “male” vs “fem”. Let’s put an internal loop: . drop *perc . foreach race of varlist total-island { 2. foreach gender in male fem { 3. gen `gender'`race'perc = `gender'`race'/`race' 4. } 5. } . list *perc in 1, ab(100) +---------------------------------------------------------------+ 1. | maletotalperc | femtotalperc | malewhiteperc | femwhiteperc | | .5116206 | .4883794 | .5130497 | .4869503 | |---------------+--------------+----------------+---------------| | maleblackperc | femblackperc | maleindianperc | femindianperc | | .5078017 | .4921983 | .5100116 | .4899884 | |---------------+--------------+----------------+---------------| | maleasianperc | femasianperc | maleislandperc | femislandperc | | .5029027 | .4970973 | .5167261 | .4832739 | +---------------------------------------------------------------+ Each time “race” gets set to a new variable, we enter another loop where “gender” gets set first to “male” then to “fem”. To help visualize it, here is what “race” and “gender” are set to each time the gen command is run: gen command “race” “gender” 1 total male 2 total fem 3 white male 4 white fem 5 black male 6 black fem 7 indian male 8 indian fem 9 asian male 10 asian fem 11 island male 12 island fem Notice the syntax of the above two foreach differs slightly: foreach &lt;macro name&gt; of varlist &lt;variables&gt; foreach &lt;macro name&gt; in &lt;list of strings&gt; It’s a bit annoying, but Stata handles the “of” and “in” slight differently. The “in” treats any strings on the right as strict. Meaning if the above loop were foreach race in total-island then Stata would set “race” to “total-island” and the gen command would run once! By using “of varlist”, you are telling Stata that before it sets “race” to anything, expand the varlist using the rules such as * and -. There is also foreach &lt;macro name&gt; of numlist &lt;list of numbers&gt; The benefit of “of numlist” is that numlists support things like 1-4 representing 1, 2, 3, 4. So foreach num of numlist 1 3-5 Loops over 1, 3, 4, 5, whereas foreach num in 1 3-5 loops over just “1” and “3-5”. The use of “in” is for when you need to loop over strings that are neither numbers nor variables (such as “male” and “fem” from above). 6.3 Suppressing output and errors There are two useful command prefixes that can be handy while writing more elaborate Do-files. 6.3.1 capture Imagine the following scenario. You want to write a Do-file that generates a new variable. However, you may need to re-run chunks of the Do-file repeatedly, so that the gen statement is hit repeatedly. After the first gen, we can’t call it again and need to use replace instead. However, if we used replace, it wouldn’t work the first time! One solution is to drop the variable before we gen it: . sysuse auto, clear (1978 Automobile Data) . drop newvar variable newvar not found r(111); . gen newvar = 1 That error, while not breaking the code, is awfully annoying! However, if we prefix it by capture, the error (and all output from the command) are “captured” and hidden. . list price in 1/5 +-------+ | price | |-------| 1. | 4,099 | 2. | 4,749 | 3. | 3,799 | 4. | 4,816 | 5. | 7,827 | +-------+ . capture list price in 1/5 . list abcd variable abcd not found r(111); . capture list abcd Therefore, the best way to generate our new variable is . capture drop newvar . gen newvar = 1 6.3.2 quietly quietly does the same basic thing as capture, except it does not hide errors. It can be useful combined with the returns: . quietly summ price . display r(mean) 6165.2568 This will come in very handy when you start running statistical models, where the output can be over a single screen, whereas you only want a small piece of it. Just to make the difference between capture and quietly clear: . list price in 1/5 +-------+ | price | |-------| 1. | 4,099 | 2. | 4,749 | 3. | 3,799 | 4. | 4,816 | 5. | 7,827 | +-------+ . quietly list price in 1/5 . capture list price in 1/5 . list abcd in 1/5 variable abcd not found r(111); . quietly list abcd in 1/5 variable abcd not found r(111); . capture list abcd in 1/5 “Local” as opposed to “global”, a distinction which is not important until you get deep into programming. For now, local is the safer option.↩ There are obviously other ways to compute this, but this gives a flavor of the use.↩ "]
]
